# 组件

## 组件是什么？

组件是Vue.js最强力的特性之一，它们帮助你扩展基本的HTML元素为概括的可复用代码。在高层次上讲，组件是用户自定义的元素，Vue.js编译器可以给它附加上特定的行为。在一些清醒下，它们可能作为带有特定的`is`属性扩展的原生HTML元素出现。

## 使用组件

### 注册

在前面一节中，我们学到了可以使用`Vue.extend()`来创建一个组件构造器。

```js
var MyComponent = Vue.extend({
  // options...
})
```

要将这个构造器作为一个组件使用，你必须使用`Vue.component(tag, constructor)`来**注册**它。

```js
// Globally register the component with tag: my-component
Vue.component('my-component', MyComponent)
```

> 注意，Vue.js并不强制要求自定义标签名遵[守W3C规则](http://www.w3.org/TR/custom-elements/#concepts)（全校鞋，必须包含一个连字符），尽管遵循这个协定被认为是一个好的练习。

一旦注册了，组件就可以被用在父实例的模版中作为一个自定义元素，`<my-component>`。确保你在初始化你的根Vue实例之前，组件已经被注册了。这里是一个完整额例子：

```HTML
<div id="example">
  <my-component></my-component>
</div>
```

```js
// define
var MyComponent = Vue.extend({
  template: '<div>A custom component!</div>'
})

// register
Vue.component('my-component', MyComponent)

// create a root instance
new Vue({
  el: '#example'
})
```

他将渲染出如下的效果：

```html
<div id="example">
  <div>A custom component!</div>
</div>
```

A Custom Component!

注意，组件的模版会**替换**自定义元素，这个自定义元素只是扮演了一个**挂载点的角色**。这个行为可以用`replace`实例选项配置。

### 本地注册

你不需要将每个组件都注册为全局的，你可以通过注册组件的时候附带上`components`实例选项来使这个组件仅在另外一个组件域内可用：

```js
var Child = Vue.extend({ /* ... */ })

var Parent = Vue.extend({
  template: '...',
  components: {
    // <my-component> will only be available in Parent's template
    'my-component': Child
  }
})
```

同样的封包会应用于别的资源类型，如指令，过滤器和过渡。

### 注册语法糖

要使事情变得容易，你可以直接传递选项对象而不是实际的构造器给`Vue.component()`和`component`选项。Vue.js会自动为你在钩子下调用`Vue.extend()`。

```js
// extend and register in one step
Vue.component('my-component', {
  template: '<div>A custom component!</div>'
})

// also works for local registration
var Parent = Vue.extend({
  components: {
    'my-component': {
      template: '<div>A custom component!</div>'
    }
  }
})
```

### 组件选项告诫

多数可以传递给Vue构造器的选项可以用在`Vue.extend()`中 ，有两个特殊的情形：`data`和`el`。想象一下我们简单地传递一个对象作为`data`给`Vue.extend()`：

```js
var data = { a: 1 }
var MyComponent = Vue.extend({
  data: data
})
```

这里的问题是，相同的`data`对象会被在所有的`MyComponents`实例间共享！这不是我们想要的，所以我们应该使用一个方法来返回一个新鲜的对象作为`data`选项：

```js
var MyComponent = Vue.extend({
  data: function () {
    return { a: 1 }
  }
})
```
当在`Vue.extend()`中使用时，`el`选项仍旧要求一个方法值，原因相同。

### 模版转换

Vue.js模版引擎是基于DOM的，它使用来自浏览器的原生的转换器，而不是提供一个自定义的。相较于基于字符串的模版引擎，这样有一些优势，但同时也有警告。模版必须是单独有效的的HTML片段，一些HTML元素对于可以在它们内部出现的元素有限制，多数这些常见的限制有：

- `a`不能包含其他可交互的元素（如按钮和别的链接）
- `li`应当直接属于`ul`或`ol`的子元素，并且`ul`和`ol`只能包含`li`元素。
- `option`只能是`select`的直接自元素，`select`只能包含`option`和`optgroup`
- `table`只能包含`thead`，`tbody`，`tfoot`和`tr`，这些元素必须是`table`的直接自元素
- `tr`只能包含`th`和`td`，这些元素必须是`tr`的直接子元素

在实际中，这些限制会导致不可预料的行为。尽管在简单的情形中，他可能会正常工作，但你不能依赖于在浏览器验证之前自定义元素被扩展了。例如：`<my-select><option>...</option></my-select`不是个有效的模版，尽管`my-select`组件最终扩展自`<select>...</select>`。

另外一个重要的问题是你不能使用自定义的标签（包括自定义元素和特殊的标签，像`<component>`，`<template>`，和`partial`）来替代`ul`，`select`，`table`和别的有同样限制的元素，自定义标签会被抛出，并因此不会被正确渲染。

在自定义元素情形中，你应当使用`is`这个特殊属性：

```html
<table>
  <tr is="my-component"></tr>
</table>
```

对于`<template>`在`<table>`内部的情形，你可以使用`<tbody>`，因为表格允许有多个`tbody`：

```html
<table>
  <tbody v-for="item in items">
    <tr>Even row</tr>
    <tr>Odd row</tr>
  </tbody>
</table>
```

## Props

### 利用Props传递数据

每个组件都有它自己的**隔离域**，这意味着你不能在一个子组件模版中引用父亲的数据。可以使用**props**来将数据向下传递给子组件。

"prop"是一个组件的data中的字段，它可以从父组件中传递下去。子组件需要明确地声明他想要使用`props`[选项](http://vuejs.org/api/#props)接收的props：

```js
Vue.component('child', {
  // declare the props
  props: ['msg'],
  // the prop can be used inside templates, and will also
  // be set as `this.msg`
  template: '<span>{{ msg }}</span>'
})
```

然后，我们可以像这样传递一个平白字符串给它：

```html
<child msg="hello!"></child>
```

结果：

Hello!

### 驼峰命名法 vs. 糖葫芦命名法

HTML属性是大小写不敏感的，当使用驼峰命名法的prop名字作为属性时，你需要使用和它们等价的糖葫芦命名法（以连字符分隔）：

```js
Vue.component('child', {
  // camelCase in JavaScript
  props: ['myMessage'],
  template: '<span>{{ myMessage }}</span>'
})
```

```html
<!-- kebab-case in HTML -->
<child my-message="hello!"></child>
```

### 动态的props

类似于给一个表达式绑定正常属性，我们也可以使用`v-bind`给父亲上的数据动态绑定props。无论合适父亲中的数据更新了，它也会向下流向儿子：

```html
<div>
  <input v-model="parentMsg">
  <br>
  <child v-bind:my-message="parentMsg"></child>
</div>
```

也可以使用`v-bind`的简记语法：

```html
<child :my-message="parentMsg"></child>
```

### 字面意义vs.动态

新手一个常见的易犯错误是想要使用字面意义的方式来传递一个数字:

```html
<!-- this passes down a plain string "1" -->
<comp some-prop="1"></comp>
```

然而，由于这是一个字面意义的prop，它的值将作为平白字符串`"1"`传递下去，而不是一个真实的数字。如果我们想要传递一个真实的JavaScript数字，我们需要使用动态语法来让它的值被评估为一个JavaScript表达式：

```html
<!-- this passes down an actual number -->
<comp :some-prop="1"></comp>
```

### Prop绑定类型

默认情况下，所有的props在子组件属性和伏组件中的哪一个之间产生一个**一步向下**绑定：当父组件的更新时，这个将会向下流向它的儿子，但不是相反的方式。这个默认意味着会阻止子组件意外地修改了父组件的状态，（如果没有阻止的话）这将导致你的应用数据流难以追溯。然而，也可以明确强制一个两步或一次绑定，利用`.sync`和`.once`**绑定类型修饰符**：

比较一下语法：

```html
<!-- default, one-way-down binding -->
<child :msg="parentMsg"></child>

<!-- explicit two-way binding -->
<child :msg.sync="parentMsg"></child>

<!-- explicit one-time binding -->
<child :msg.once="parentMsg"></child>
```

两步绑定会将儿子的`msg`属性的改变同步回父亲的`parentMsg`属性。一次绑定，一旦建立，将不会同步在父亲和儿子之间的未来的更改。

> 注意，如果传递下去的prop是个对象或一个数组，则它是根据引用传递。改变儿子内的Objet或Array自身**将会**影响父亲的状态，不管正在使用的绑定类型是什么。
