# 方法和事件处理

## 方法处理器

可以使用`v-on`指令来监听DOM事件：

```html
<div id="example">
  <button v-on:click="greet">Greet</button>
</div>
```

我们绑定了一个点击事件监听器到一个名字为`greet`的方法上。这里是那个方法在Vue实例中的定义：

```js
var vm = new Vue({
  el: '#example',
  data: {
    name: 'Vue.js'
  },
  // define methods under the `methods` object
  methods: {
    greet: function (event) {
      // `this` inside methods point to the Vue instance
      alert('Hello ' + this.name + '!')
      // `event` is the native DOM event
      alert(event.target.tagName)
    }
  }
})

// you can invoke methods in JavaScript too
vm.greet() // -> 'Hello Vue.js!'
```

## 行内声明处理器

除了直接绑定一个方法名，我们也可以使用一个行内JavaScript声明：

```html
<div id="example-2">
  <button v-on:click="say('hi')">Say Hi</button>
  <button v-on:click="say('what')">Say What</button>
</div>
```

```js
new Vue({
  el: '#example-2',
  methods: {
    say: function (msg) {
      alert(msg)
    }
  }
})
```

与行内表达式的限制相同，这种的事件处理器被限制为**仅仅一个声明**。

有时，我们需要在行内声明处理器中访问原始的DOM事件，你可以使用特殊的`$event`变量将它传入一个方法：

```html
<button v-on:click="say('hello!', $event)">Submit</button>
```

```js
// ...
methods: {
  say: function (msg, event) {
    // now we have access to the native event
    event.preventDefault()
  }
}
```

## 事件修饰符

在事件处理器内调用`event.preventDefault()`或`event.stopPropagation()`很常见，尽管我们可以很容易地在方法内做到这个，但如果能专注于逻辑处理而不是DOM事件细节就更好了。

要处理这个问题，Vue.js给`v-on`提供了两个**事件修饰符**：`.prevent`和`.stop`。调用修饰符的方式是由点标注的指令后缀；

```html
<!-- the click event's propagation will be stopped -->
<a v-on:click.stop="doThis"></a>

<!-- the submit event will no longer reload the page -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- modifiers can be chained -->
<a v-on:click.stop.prevent="doThat">

<!-- just the modifier -->
<form v-on:submit.prevent></form>
```

在1.0.16中，新入了两个额外的修饰符：

```html
<!-- use capture mode when adding the event listener -->
<div v-on:click.capture="doThis">...</div>

<!-- only trigger handler if event.target is the element itself -->
<!-- i.e. not from a child element -->
<div v-on:click.self="doThat">...</div>
```

## 键修饰符

当监听键盘事件，我们通常要检查键码。Vue.js还允许在监听键盘事件的时候给`v-on`添加键盘修饰符：

```html
<!-- only call vm.submit() when the keyCode is 13 -->
<input v-on:keyup.13="submit">
```

记住所有的键码是个麻烦事，所以Vue.js给大多数常用的键起了别名：

```html
<!-- same as above -->
<input v-on:keyup.enter="submit">

<!-- also works for shorthand -->
<input @keyup.enter="submit">
```

这里是个键修饰符的完整列表：
- enter
- tab
- delete
- esc
- space
- up
- down
- left
- right

1.0.8+: 单字母键别名依旧支持。
1.0.17+: 你也可以自己定义键修饰符别名：

```js
// enable @keyup.f1
Vue.directive('on').keyCodes.f1 = 112
```

## 为什么在HTML中有监听器？

你可能会觉得，这整个事件监听违反了之前比较好的“关系隔离”规则。请放心——由于所有的Vue.js的处理器方法he表达式都严格地绑定到了处理当前视图的ViewModel上，它不会导致任何维护麻烦。实际上，使用`v-on`还有一些福利：

1. 它使得略过HTML模版来定位处理器方法实现变得容易。
1. 由于你不需要在JS中手动附加事件监听器，你的ViewModel代码只是纯逻辑，并且和DOM无关，这使测试变得容易。
1. 当一个ViewModel销毁了，所有的事件监听器都会自动被销毁。你不需要担心需要自己来清除它。
