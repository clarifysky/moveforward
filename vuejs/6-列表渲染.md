# 列表渲染

## v-for

可以使用`v-for`来渲染基于数组的列表。`v-for`指令需要一个形式为`item in items`的特殊语法，`items`是数组的源数据，`item`是数组的一个正在迭代的元素的**别名**。

例子：

```html
<ul id="example-1">
  <li v-for="item in items">
    {{ item.message }}
  </li>
</ul>
```

```js
var example1 = new Vue({
  el: '#example-1',
  data: {
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
  }
})
```

结果：

- Foo
- Bar

在`v-for`代码块内，有充分的权限访问父域的属性，加上一个特殊的变量`$index`，你可能猜到了，它是当前数组元素的索引：

```html
<ul id="example-2">
  <li v-for="item in items">
    {{ parentMessage }} - {{ $index }} - {{ item.message }}
  </li>
</ul>
```

```js
var example2 = new Vue({
  el: '#example-2',
  data: {
    parentMessage: 'Parent',
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
  }
})
```

结果：

- Parent-0-Foo
- Parent-1-Bar

或者，你也可以为索引指定一个别名（或者是键，如果`v-for`用于一个对象的话）：

```html
<div v-for="(index, item) in items">
  {{ index }} {{ item.message }}
</div>
```

从1.0.17开始，你也可以使用`of`作为分隔符来替代`if`，这很贴近JavaScript的迭代语法：

```html
<div v-for="item of items"></div>
```

## 模版v-for

类似于模版`v-if`，你也可结合`v-for`来使用`<template>`标签来渲染一个多元素块：

```html
<ul>
  <template v-for="item in items">
    <li>{{ item.msg }}</li>
    <li class="divider"></li>
  </template>
</ul>
```

## 数组更改监测

### 突变方法

Vue.js包裹了一个被监测的数组的突变方法，它们也可以触发视图更新。包裹的方法有：

- `push()`
- `pop()`
- `shift()`
- `unshift()`
- `splice()`
- `sort()`
- `reverse()`

你可以打开控制台，调用他的突变方法来测试前一个示例的`items`数组。例如：`example1.items.push({ message: 'Baz' })`。

### 替换数组

突变方法，如名字那样，会改变调用它的数组的原始值。对比来说，也有非突变方法，例如`filter()`，`concat()`和`slice()`，这些不会改变原始数组，但会**返回一个新数组**。当处理不突变的方法时，你可以仅仅将旧数组用新数组替换掉：

```js
example1.items = example1.items.filter(function (item) {
  return item.message.match(/Foo/)
})
```

你或许觉得这将导致Vue.js抛掉已存在的DOM，并重新渲染整个列表——幸运的是，并非如此。Vue.js实现了一些智能启发式的东西来最大化DOM元素的复用率，所以用有交集的数组对象替换掉当前数组是一个非常高效的操作。

### 被追踪
有时候，你想要彻底换掉整个数组，例如是一个来自API调用的数组。由于默认情况下，`v-for`根据追踪它的data对象的标识来确定当前域和DOM元素的重用性，这可能会导致整个列表被重绘。然而，如果你的每个数据对象有个唯一的id属性，那么你就可以使用`track-by`来给Vue.js一个提示让它能够最大限度地重用已经存在的实例。

例如，如果你的data看起来是这样：

```js
{
  items: [
    { _uid: '88f869d', ... },
    { _uid: '7496c10', ... }
  ]
}
```

那么你可以这样发出提示：

```html
<div v-for="item in items" track-by="_uid">
  <!-- content -->
</div>
```

以后，当你替换掉了`items`数组，Vue.js发现了一个带有`_uid: '88f869d'`的新对象，它就会知道，它可以重用和同一个`_uid`关联的已经存在的域和DOM元素。

### 被$index追踪

如果你没有要用来追踪的唯一标识，你也可以使用`track-by="$index"`，它会强制`v-for`进入适当的更新模式：碎片不再会被搬来搬去，它们只是在对应的索引处连带新值被冲刷出去。这个模式也可以应对在源数组中的重复值。

这使得数组替换极为高效，但是有代价的。因为DOM节点不再移动来对应顺序更改，DOM的输入状态和组件的私有状态会跳出同步。所以，在`v-for`代码块包含表单输入元素和子组件时要小心使用`track-by="$index"`。

### 告诫

由于JavaScript的限制，Vue.js**无法**侦测到下面的数组更改：

1. 当你直接设置带有所以的item时，例如：`vm.items[0] = {};`。
1. 当你修改数组的长度时，例如：`vm.items.lenght = 0;`。

要处理告诫1，Vue.js使用$set()方法讨论监视的数组：

```js
// same as `example1.items[0] = ...` but triggers view update
example1.items.$set(0, { childMsg: 'Changed!'})
```

要处理告诫2，Vue.js同样使用一个简便的方法`$remove()`讨论数组，他会搜索，并在内部通过调用`splice()`来从目标数组移除一个元素。所以，对于：

```js
var index = this.items.indexOf(item)
if (index !== -1) {
  this.items.splice(index, 1)
}
```

你可以仅仅这么做：

```js
this.items.$remove(item)
```

**使用`Object.freeze()`**

当迭代一个被`Object.freeze()`冻结的对象的数组是，你需要明确地使用`track-by`键。在这个场景下，如果Vue.js不能自动跟踪对象，一个警告就会显示出来。

## 对象 v-for

你也可以使用`v-for`来迭代一个对象的属性，除了`$index`之外，每一个域都有访问别的特殊属性`$key`的权限。

```html
<ul id="repeat-object" class="demo">
  <li v-for="value in object">
    {{ $key }} : {{ value }}
  </li>
</ul>
```

```js
new Vue({
  el: '#repeat-object',
  data: {
    object: {
      FirstName: 'John',
      LastName: 'Doe',
      Age: 30
    }
  }
})
```

结果：

- FirstName: John
- LastName: Doe
- Age: 30

你也可以为键设置一个别名：

```html
<div v-for="(key, val) in object">
  {{ key }} {{ val }}
</div>
```

> 当彻底迭代一个对象时，顺序是基于`Objects.keys()`的键枚举顺序，在所有的JavaScript迎庆实现中，他的一致性不被保证。

## 区间 v-for

`v-for`也可以接收一个整数，在这个例子中，它会重复模版多次。

```html
<div>
  <span v-for="n in 10">{{ n }} </span>
</div>
```

结果：

0 1 2 3 4 5 6

## 显示过滤的/排序的结果

有时我们只需要显示数组的一些过滤的或排过序的结果，而不是真正的改变或重设它的原始值。有两个方式可以达到这个目的：

1. 创建一个计算属性来返回过滤过的或排过序的数组
1. 使用内置的`filterBy`和`orderBy`过滤器

计算属性给你了易辨识的控制和灵活性，因为它是彻底的JavaScript，但过滤器可能在常见用例中更方便。关于数组过滤器的使用细节，参考它们的[文档](http://vuejs.org/api/#filterBy)。
