# 计算的属性

模版内表达式非常方便，但它们只意味着简单的操作。模版代只用来描述视图的结构，放置太多的逻辑到模版中会使它变得臃肿和难以维护。这就是为什么Vue.js限制绑定表达式到一个表达式中的原因。对于任意一个需要超过一个表达式的逻辑，你应该使用一个**计算的属性**。

## 基本的例子

```html
<div id="example">
  a={{ a }}, b={{ b }}
</div>
```

```js
var vm = new Vue({
  el: '#example',
  data: {
    a: 1
  },
  computed: {
    // a computed getter
    b: function () {
      // `this` points to the vm instance
      return this.a + 1
    }
  }
})
```

结果：
a=1,b=2

这里，我们声明了一个计算属性`b`，我们提供的方法会被用作`vm.b`属性的读取器方法：

```js
console.log(vm.b) // -> 2
vm.a = 2
console.log(vm.b) // -> 3
```

你可以打开控制台，随便测试这个vm例子，`vm.b`的值始终依赖于`vm.a`的值。

你可以在模版中像正常属性那样数据绑定到计算属性上，Vue明白`vm.b`基于`vm.a`，所以它会更新任意基于`vm.b`的绑定，当`vm.a`改变时。最好的部分是我们声明式地创建了这个依赖关系：计算读取器方法是纯净的，没有其他效果，这很方便测试和找出原因。

## 计算属性vs.$watch

Vue.js提供了一个`$watch`API允许你来观测一个Vue实例上的数据变化。当你有一些基于别的数据的数据要更改，就会尝试使用`$watch`－尤其是你来自一个AngularJS背景。然而，使用计算属性比使用一个强制的`$watch`回调要好。考虑下面的例子：

```html
<div id="demo">{{fullName}}</div>
```

```js
var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar',
    fullName: 'Foo Bar'
  }
})

vm.$watch('firstName', function (val) {
  this.fullName = val + ' ' + this.lastName
})

vm.$watch('lastName', function (val) {
  this.fullName = this.firstName + ' ' + val
})
```

上面的代码是复杂的，重复的，比较一下计算属性版本：

```js
var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar'
  },
  computed: {
    fullName: function () {
      return this.firstName + ' ' + this.lastName
    }
  }
})
```

这更好一点，不是吗？

### 计算存储器

计算属性默认只是读取器，但你也可以在需要的时候提供一个存储器：

```js
// ...
computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
// ...
```

现在，当你调用`vm.fullName = 'John Doe'`，存储器会被调用，`vm.firstName`和`vm.lastName`会被相应地更新。

计算属性如何更新背后的技术细节在奉献给了回馈式系统的[另外一个部分有所讨论](http://vuejs.org/guide/reactivity.html#Inside-Computed-Properties)。
